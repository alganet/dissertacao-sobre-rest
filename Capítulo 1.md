# CAPÍTULO 1

## Arquitetura de Software

Apesar do interesse em arquitetura de software como um campo de pesquisa, há pouco consenso entre os pesquisadores quanto ao que exatamente deve ser incluída na definição de arquitetura. Em muitos casos, isso levou os aspectos de importantes projetos arquitetôticos serem negligenciados por pesquisas anteriores. Este capítulo define uma terminologia auto-consistente para a arquitetura de software baseada na avaliação de definições existentes na literatura e minha própria visão no que diz respeito à arquiteturas de aplicativos baseados em rede. Cada definição, destacados em uma caixa de texto para facilitar a referência, é seguida por uma discussão de onde ela foi derivada, ou a qual se compara, em relação a pesquisa relacionada.


### 1.1 Abstração de Tempo de Execução (Run-time)

> A **arquitetura de software** é uma abstração dos elementos de tempo de execução (run-time) de um sistema de software durante alguma fase de sua operação. Um sistema pode ser composto de diversos níveis de abstração e muitas fases da operação, cada um com sua própria arquitetura de software.

No coração da arquitetura de software, é o princípio da abstração: esconder alguns dos detalhes de um sistema por meio de encapsulamento, a fim de melhor identificar e sustentar suas propriedades [[117](Referências#117)]. Um sistema complexo irá conter vários níveis de abstração, cada um com sua própria arquitetura. Uma arquitetura representa uma abstração do comportamento do sistema no seu próprio nível, de modo a que elementos arquitetônicos são delineadas pelas interfaces abstratas que prestam aos outros elementos a esse nível [[9](Referências#9)]. Dentro de cada elemento pode ser encontrada outra arquitetura, definindo o sistema de sub-elementos que implementam o comportamento representado pela interface abstrata do elemento pai. Esta recursão de arquiteturas continua até os elementos mais básicos do sistema: aqueles que não podem ser decompostos em elementos menos abstratos.

Além níveis de arquitetura, um sistema de software, muitas vezes, têm múltiplas fases operacionais, tais como *start-up*, a inicialização, o processamento normal, re-inicialização e desligamento. Cada fase operacional tem sua própria arquitetura. Por exemplo, um arquivo de configuração será tratado como um elemento de dados durante a fase de *start-up*, mas não será considerado um elemento arquitectônico durante o processamento normal, uma vez que nesse momento a informação que continha já terá sido distribuído por todo o sistema. Isto pode, de fato, ter definido a arquitetura de processamento normal. Uma descrição geral de uma arquitetura de sistema deve ser capaz de descrever não só o comportamento operacional da arquitetura do sistema durante cada fase, mas também a arquitetura de transições entre as fases.

**Perry e Wolf** [[105](Referências#105)] definem elementos de processamento como "transformadores de dados", enquanto **Shaw et al.** [[118](Referências#118)] descrevem componentes como "o locus da computação e do Estado". Isto é melhor esclarecido em **Shaw e Clements** [[122](Referências#122)]: "Um componente é uma unidade de software que executa alguma função em tempo de execução (run-time). Exemplos incluem programas, objetos, processos e filtros". Isto levanta uma importante distinção entre arquitetura de software e o que é normalmente referido como estrutura de software: a primeira é uma abstração do comportamento de tempo de execução (run-time) de um sistema de software, enquanto a segunda é uma propriedade do código-fonte do software estático. Embora haja vantagens em se ter a estrutura modular do código-fonte em harmonia com a decomposição de comportamento de um sistema em execução, também há vantagens em ter componentes de software independentes sendo implementados usando partes do mesmo código (por exemplo, bibliotecas compartilhadas). Separamos o ponto de vista de arquitetura de software da do código-fonte, a fim de concentrarmos em características de tempo de execução (run-time) do software independentes da execução de um determinado componente. Portanto, *design* de arquitetura e *design* estrutural de código-fonte, embora intimamente relacionados, são atividades de *design* de software separadas. Infelizmente, algumas descrições de arquitetura de software não conseguem fazer essa distinção (por exemplo, [[9](Referências#9)]).


### 1.2 Elementos

> Uma arquitectura de software é definido por uma configuração dos elementos de arquitetura - componentes, conectores e dados - restritas em suas relações a fim de alcançar um conjunto desejado de propriedades de arquitectura.

Um exame abrangente do escopo e base intelectual para a arquitetura de software pode ser encontrado em **Perry e Wolf** [[105](Referências#105)]. Eles apresentam um modelo que define uma arquitetura de software como um conjunto de elementos arquitetônicos que têm uma forma particular, explicados por um conjunto de lógica (*rationale*). Os elementos arquitetônicos incluem o processamento, dados e elementos de ligação. Forma é definida pelas propriedades dos elementos e as relações entre os elementos - ou seja, as restrições relativas aos elementos. A lógica (*rationale*) fornece a base subjacente para a arquitetura, capturando a motivação para a escolha do estilo arquitetônico, a escolha de elementos, e a forma.

Minhas definições para arquitetura de software são uma versão elaborada das descritas no modelo de **Perry e Wolf** [[105](Referências#105)], exceto o fato de eu excluir a lógica (*rationale*). Embora lógica (*rationale*) seja um aspecto importante para a pesquisa de arquitetura de software e da descrição da arquitetura em particular, incluindo-a na definição de arquitetura de software implicaria que a documentação de *design* do projeto seja parte do sistema de tempo de execução (run-time). A presença ou ausência de lógica (*rationale*) pode influenciar na evolução de uma arquitetura, mas, uma vez constituída, a arquitetura é independente das suas razões de existir. **Sistemas reflexivos** [[80](Referências#80)] podem usar as características de desempenho passado para mudar o comportamento futuro, mas ao fazê-lo estão substituindo uma arquitetura de nível inferior com uma outra arquitetura de nível mais baixo, em vez de lógica (*rationale*) abrangente dentro dessas arquiteturas.

Como ilustração, considere o que acontece a um edifício, se seus projetos e planos de *design* são queimados. O edifício irá desmoronar imediatamente? Não, desde que as propriedades pelas quais as paredes sustenta o peso do telhado permanecerem intactos. Uma arquitetura tem, pelo *design*, um conjunto de propriedades que lhe permitem atender ou exceder os requisitos de sistema. A ignorância dessas propriedades pode levar a alterações posteriores que violam a arquitetura, assim como a substituição de um muro de suporte de carga, com uma grande moldura da janela pode violar a estabilidade estrutural de um edifício. Assim, em vez de lógica (*rationale*), a nossa definição de arquitetura de software inclui propriedades arquitetônicas. A lógica (*rationale*) fundamenta essas propriedades, e falta de lógica (*rationale*) pode resultar na deterioração gradual ou degradação da arquitetura ao longo do tempo, mas a lógica (*rationale*), propriamente dita, não faz parte da arquitetura.

Uma característica fundamental do modelo em **Perry e Wolf** [[105](Referências#105)] é a distinção dos vários tipos de elementos. *Elementos de processamento* são aqueles que executam transformações em dados, *elementos de dados* são aqueles que contêm a informação que é usada e transformada e *elementos de ligação* são a cola que mantém as diferentes peças da arquitetura juntas. Eu uso os termos mais prevalentes de *componentes* e *conectores* para me referir a elementos de processamento e de ligação, respectivamente.

**Garlan e Shaw** [[53](Referências#53)] descrevem uma arquitetura de um sistema como um conjunto de componentes computacionais em conjunto com uma descrição das interacções entre estas componentes - os conectores. Este modelo é abordado mais profundamente em **Shaw et al.** [[118](Referências#118)]: A arquitetura de um sistema de software define o sistema, em termos de componentes e de interacções entre esses componentes. Além disso, para especificar a estrutura e topologia do sistema, a arquitectura mostra a correspondência pretentendia entre os requisitos de sistema e elementos de sistema construído. O desenvolvimento mais avançado desta definição pode ser encontrada em **Shaw e Garlan** [[121](Referências#121)].

O que é surpreendente sobre o modelo de **Shaw et al.** [[118](Referências#118)] é que, em vez de definir a arquitetura de software como existindo dentro do software, ele está definindo uma descrição da arquitetura de software como se isso fosse a arquitetura. No processo, a arquitetura de software como um todo é reduzida ao que é comumente encontrada em mais informais diagramas de arquitetura: caixas (componentes) e linhas (conectores). Os elementos de dados, juntamente com muitos dos aspectos dinâmicos de arquiteturas de software real, são ignorados. Tal modelo é incapaz de descrever adequadamente as arquiteturas de software baseadas em rede, uma vez que a natureza, localização e movimento dos elementos de dados dentro do sistema são, muitas vezes, os únicos e mais relevantes determinantes do comportamento do sistema.


#### 1.2.1 Componentes

> Um componente é uma unidade abstrata de instruções de software e um estado interno que proporciona uma transformação de dados através de sua interface.

Componentes são aspectos mais facilmente reconhecidos na arquitetura de software. Os elementos de processamento de **Perry e Wolf** [[105](Referências#105)] são definidos como aqueles componentes que fornecem a transformação em elementos de dados. **Garlan e Shaw** [[53](Referências#53)] descrevem componentes simplesmente como os elementos que realizam computação. A nossa definição tenta ser mais preciso em fazer a distinção entre os componentes e o software dentro de conectores.

Um componente é uma unidade abstrata de instruções de software e um estado interno que proporciona uma transformação de dados através de sua interface. Exemplos de transformações incluem carregar na memória de armazenamento secundário, realizar alguns cálculos, traduzindindo para um formato diferente, encapsulamento com outros dados, etc. O comportamento de cada componente é parte da arquitetura enquanto o comportamento pode ser observado ou discernido a partir do ponto de vista de um outro componente de [[9](Referências#9)]. Em outras palavras, um componente é definido pela sua interface e os serviços que ele fornece a outros componentes, em vez de pela sua aplicação por trás da interface. **Parnas** [[101](Referências#101)] definiria isto como o conjunto de pressupostos que outros elementos arquitetônicos podem construir em relação a outros componente.


#### 1.2.2 Conectores

> Um conector é um mecanismo abstrato que intermedia a comunicação, a coordenação ou a cooperação entre os componentes.

**Perry e Wolf** [[105](Referências105)] descrevem elementos de ligação vagamente como a cola que mantém as várias partes da arquitetura juntos. Uma definição mais precisa é fornecida por **Shaw e Clements** [[122](Referências#122)]: Um conector é um mecanismo abstrato que intermedia a comunicação, a coordenação ou a cooperação entre os componentes. Exemplos incluem representações compartilhadas, chamadas de procedimento remoto, protocolos de transmissão de mensagens e fluxos de dados.

Talvez a melhor maneira de pensar sobre conectores é contrastá-las com os componentes. Conectores habilitam a comunicação entre os componentes através da transferência de elementos de dados de uma interface para uma outra, sem alterar os dados. Internamente, um conector pode ser constituído por um subsistema de componentes que transformam os dados para a transferência, efetuam a transferência, e, em seguida, a transformação inversa de entrega. No entanto, a abstração do comportamento externo capturado pela arquitetura ignora esses detalhes. Em contraste, um componente pode, mas não sempre, transformar os dados a partir da perspectiva externa.


#### 1.2.3 Dados

> Um dado *(datum)* é um elemento de informação que é transferida a partir de um componente, ou recebida por um componente, através de um conector.

Como observado acima, a presença de elementos de dados é a diferença mais significativa entre o modelo de arquitetura de software definido por **Perry e Wolf** [[105](Referências#105)] e o modelo utilizado por grande parte da pesquisa de arquitetura de software marcado em [[1](Referências#1), [5](Referências#5), [9](Referências#9), [53](Referências#53), [56](Referências#56), [117](Referências#177)-[122](Referências#122), [128](Referências#128)]. **Boasson** [[24](Referências#24)] critica a pesquisa atual de arquitetura de software pois a sua ênfase em estruturas de componentes e ferramentas de desenvolvimento de arquitetura, sugerindo que mais foco deveria ser dado em modelagem arquitetônica centrada em dados. Comentários similares são feitas por **Jackson** [[67](Referências#67)].

Um dado (*datum*) é um elemento de informação que é transferida a partir de um componente, ou recebida por um componente, através de um conector. Exemplos incluem sequências de byte (*byte-sequences*), mensagens, parâmetros mobilizados e objetos serializados, mas não incluem informações que são residentes permanentemente ou escondidas dentro de um componente. Do ponto de vista arquitetônico, um "arquivo" é uma transformação que um componente do sistema de arquivos pode fazer a partir dos dados recebidos de um "nome de arquivo" em sua interface para uma seqüência de bytes gravados dentro de um sistema de armazenamento escondido internamente. Os componentes também podem gerar dados, como no caso de um encapsulamento de um relógio ou sensor.

A natureza dos elementos de dados dentro de uma arquitetura de aplicativo baseada em rede, muitas vezes, determinará um determinado estilo arquitetônico é apropriado ou não. Isto é particularmente evidente na comparação dos paradigmas de *design* de codificação de códigos móveis [[50](Referências#50)], em que a escolha deve ser feita entre interagir com um componente diretamente ou transformar o componente em um elemento de dados, transferindo-o através de uma rede, e em seguida, transformá-lo de volta a um componente que pode ser interagido localmente. É impossível avaliar tal arquitetura sem considerar os elementos de dados a nível arquitetônico.


### 1.3 Configurações

> Uma configuração é a estrutura das relações entre os componentes arquitetônicos, conectores e dados durante um período de tempo de execução do sistema.

**Abowd et al.** [[1](Referências#1)] definem a descrição arquitetônica como o apoio à descrição dos sistemas em termos de três classes sintáticas básicas: componentes, que são o *locus* da computação; conectores, que definem as interações entre os componentes e configurações, que são coleções de componentes e conectores que se interagem. Várias notações concretas de estilos específicos podem ser usadas para representar estas classes sintáticas básicas visualmente, facilitar a descrição dos cálculos legais e interações, e restringir o conjunto de sistemas desejáveis.

Falando de maneira restrita, pode-se pensar em uma configuração como sendo equivalente a um conjunto de restrições específicas sobre a interação de componentes. Por exemplo, **Perry e Wolf** [[105](Referências#105)] incluem topologia em sua definição de relações de formas arquitetônicas. No entanto, separando a topologia ativa de restrições mais generalizadas permite que um arquiteto de diferencie a configuração ativa do domínio em potencial de todas as configurações legítimas. Lógica *(rationale)* adicional para distinguir configurações dentro de linguagens de descrição de arquitetura é apresentado em **Medvidovic e Taylor** [[86](Referências#86)].


### 1.4 Propriedades

O conjunto de propriedades arquitetônicas de uma arquitetura de software inclui todas as propriedades que derivam da seleção e disposição dos componentes, conectores e dados do sistema. Exemplos incluem tanto as propriedades funcionais adquiridas pelo sistema e propriedades não-funcionais, tais como a facilidade relativa de evolução, a reutilização de componentes, eficiência e extensibilidade dinâmica, frequentemente referidos como atributos de qualidade [[9](Referências)].

Propriedades são induzidas pelo conjunto de restrições dentro de uma arquitetura. As restrições são, muitas vezes, motivadas pela aplicação de um princípio de engenharia de software [[58](Referências#58)] com um aspecto dos elementos de arquitectura. Por exemplo, o estilo **pipe-and-filter** uniforme obtém as qualidades de reutilização de componentes e configurabilidade da aplicação através da aplicação generalidade a suas interfaces de componentes - restringindo os componentes de um único tipo de interface. Assim, a restrição de arquitectura é **componente de interface uniforme**, motivada por princípio a generalidade, a fim de obter duas qualidades desejáveis ​​que se tornarão as propriedades de arquitetura de componentes reutilizáveis ​​e configuráveis ​​quando esse estilo é instanciado dentro de uma arquitetura.

O objetivo do *design* arquitetônico é criar uma arquitetura com um conjunto de propriedades arquitetônicas que formam um superconjunto dos requisitos do sistema. A importância relativa das diferentes propriedades de arquitetura depende da natureza do sistema a que se destinam. A [Seção 2.3](Capítulo 2#2.3 Architectural Properties of Key Interest) examina as propriedades que são de interesse particular para arquiteturas de aplicativos baseados em rede.

