# CAPÍTULO 1

## Arquitetura de Software

Apesar do interesse em arquitetura de software como um campo de pesquisa, há pouco consenso entre os pesquisadores quanto ao que exatamente deve ser incluída na definição de arquitetura. Em muitos casos, isso levou os aspectos de importantes projetos arquitetôticos serem negligenciados por pesquisas anteriores. Este capítulo define uma terminologia auto-consistente para a arquitetura de software baseada na avaliação de definições existentes na literatura e minha própria visão no que diz respeito à arquiteturas de aplicativos baseados em rede. Cada definição, destacados em uma caixa de texto para facilitar a referência, é seguida por uma discussão de onde ela foi derivada, ou a qual se compara, em relação a pesquisa relacionada.

### 1.1 Abstração de Tempo de Execução (Run-time)

> A **arquitetura de software** é uma abstração dos elementos de tempo de execução (run-time) de um sistema de software durante alguma fase de sua operação. Um sistema pode ser composto de diversos níveis de abstração e muitas fases da operação, cada um com sua própria arquitetura de software.

No coração da arquitetura de software, é o princípio da abstração: esconder alguns dos detalhes de um sistema por meio de encapsulamento, a fim de melhor identificar e sustentar suas propriedades [[117](Referências#117)]. Um sistema complexo irá conter vários níveis de abstração, cada um com sua própria arquitetura. Uma arquitetura representa uma abstração do comportamento do sistema no seu próprio nível, de modo a que elementos arquitetônicos são delineadas pelas interfaces abstratas que prestam aos outros elementos a esse nível [[9](Referências#9)]. Dentro de cada elemento pode ser encontrada outra arquitetura, definindo o sistema de sub-elementos que implementam o comportamento representado pela interface abstrata do elemento pai. Esta recursão de arquiteturas continua até os elementos mais básicos do sistema: aqueles que não podem ser decompostos em elementos menos abstratos.

Além níveis de arquitetura, um sistema de software, muitas vezes, têm múltiplas fases operacionais, tais como *start-up*, a inicialização, o processamento normal, re-inicialização e desligamento. Cada fase operacional tem sua própria arquitetura. Por exemplo, um arquivo de configuração será tratado como um elemento de dados durante a fase de *start-up*, mas não será considerado um elemento arquitectônico durante o processamento normal, uma vez que nesse momento a informação que continha já terá sido distribuído por todo o sistema. Isto pode, de fato, ter definido a arquitetura de processamento normal. Uma descrição geral de uma arquitetura de sistema deve ser capaz de descrever não só o comportamento operacional da arquitetura do sistema durante cada fase, mas também a arquitetura de transições entre as fases.

**Perry e Wolf** [[105](Referências#105)] define elementos de processamento como "transformadores de dados", enquanto **Shaw et al.** [[118](Referências#118)] descrevem componentes como "o locus da computação e do Estado". Isto é melhor esclarecido em **Shaw e Clements** [[122](Referências#122)]: "Um componente é uma unidade de software que executa alguma função em tempo de execução (run-time). Exemplos incluem programas, objetos, processos e filtros". Isto levanta uma importante distinção entre arquitetura de software e o que é normalmente referido como estrutura de software: a primeira é uma abstração do comportamento de tempo de execução (run-time) de um sistema de software, enquanto a segunda é uma propriedade do código-fonte do software estático. Embora haja vantagens em se ter a estrutura modular do código-fonte em harmonia com a decomposição de comportamento de um sistema em execução, também há vantagens em ter componentes de software independentes sendo implementados usando partes do mesmo código (por exemplo, bibliotecas compartilhadas). Separamos o ponto de vista de arquitetura de software da do código-fonte, a fim de concentrarmos em características de tempo de execução (run-time) do software independentes da execução de um determinado componente. Portanto, *design* de arquitetura e *design* estrutural de código-fonte, embora intimamente relacionados, são atividades de *design* de software separadas. Infelizmente, algumas descrições de arquitetura de software não conseguem fazer essa distinção (por exemplo, [[9](Referências#9)]).

### 1.2 Elementos

> Uma arquitectura de software é definido por uma configuração dos elementos de arquitetura - componentes, conectores e dados - restritas em suas relações a fim de alcançar um conjunto desejado de propriedades de arquitectura.

Um exame abrangente do escopo e base intelectual para a arquitetura de software pode ser encontrado em **Perry e Wolf** [[105](Referências#105)]. Eles apresentam um modelo que define uma arquitetura de software como um conjunto de elementos arquitetônicos que têm uma forma particular, explicados por um conjunto de lógica (*rationale*). Os elementos arquitetônicos incluem o processamento, dados e elementos de ligação. Forma é definida pelas propriedades dos elementos e as relações entre os elementos - ou seja, as restrições relativas aos elementos. A lógica (*rationale*) fornece a base subjacente para a arquitetura, capturando a motivação para a escolha do estilo arquitetônico, a escolha de elementos, e a forma.

Minhas definições para arquitetura de software são uma versão elaborada das descritas no modelo de **Perry e Wolf** [[105](Referências#105)], exceto o fato de eu excluir a lógica (*rationale*). Embora lógica (*rationale*) seja um aspecto importante para a pesquisa de arquitetura de software e da descrição da arquitetura em particular, incluindo-a na definição de arquitetura de software implicaria que a documentação de *design* do projeto seja parte do sistema de tempo de execução (run-time). A presença ou ausência de lógica (*rationale*) pode influenciar na evolução de uma arquitetura, mas, uma vez constituída, a arquitetura é independente das suas razões de existir. **Sistemas reflexivos** [[80](Referências#80)] podem usar as características de desempenho passado para mudar o comportamento futuro, mas ao fazê-lo estão substituindo uma arquitetura de nível inferior com uma outra arquitetura de nível mais baixo, em vez de lógica (*rationale*) abrangente dentro dessas arquiteturas.

Como ilustração, considere o que acontece a um edifício, se seus projetos e planos de *design* são queimados. O edifício irá desmoronar imediatamente? Não, desde que as propriedades pelas quais as paredes sustenta o peso do telhado permanecerem intactos. Uma arquitetura tem, pelo *design*, um conjunto de propriedades que lhe permitem atender ou exceder os requisitos de sistema. A ignorância dessas propriedades pode levar a alterações posteriores que violam a arquitetura, assim como a substituição de um muro de suporte de carga, com uma grande moldura da janela pode violar a estabilidade estrutural de um edifício. Assim, em vez de lógica (*rationale*), a nossa definição de arquitetura de software inclui propriedades arquitetônicas. A lógica (*rationale*) fundamenta essas propriedades, e falta de lógica (*rationale*) pode resultar na deterioração gradual ou degradação da arquitetura ao longo do tempo, mas a lógica (*rationale*), propriamente dita, não faz parte da arquitetura.

Uma característica fundamental do modelo em **Perry e Wolf** [[105](Referências#105)] é a distinção dos vários tipos de elementos. *Elementos de processamento* são aqueles que executam transformações em dados, *elementos de dados* são aqueles que contêm a informação que é usada e transformada e *elementos de ligação* são a cola que mantém as diferentes peças da arquitetura juntas. Eu uso os termos mais prevalentes de *componentes* e *conectores* para me referir a elementos de processamento e de ligação, respectivamente.

**Garlan e Shaw** [[53](Referências#53)] descreve uma arquitetura de um sistema como um conjunto de componentes computacionais em conjunto com uma descrição das interacções entre estas componentes - os conectores. Este modelo é abordado mais profundamente em **Shaw et al.** [[118](Referências#118)]: A arquitetura de um sistema de software define o sistema, em termos de componentes e de interacções entre esses componentes. Além disso, para especificar a estrutura e topologia do sistema, a arquitectura mostra a correspondência pretentendia entre os requisitos de sistema e elementos de sistema construído. O desenvolvimento mais avançado desta definição pode ser encontrada em **Shaw e Garlan** [[121](Referências#121)].

O que é surpreendente sobre o modelo de **Shaw et al.** [[118](Referências#118)] é que, em vez de definir a arquitetura de software como existindo dentro do software, ele está definindo uma descrição da arquitetura de software como se isso fosse a arquitetura. No processo, a arquitetura de software como um todo é reduzida ao que é comumente encontrada em mais informais diagramas de arquitetura: caixas (componentes) e linhas (conectores). Os elementos de dados, juntamente com muitos dos aspectos dinâmicos de arquiteturas de software real, são ignorados. Tal modelo é incapaz de descrever adequadamente as arquiteturas de software baseadas em rede, uma vez que a natureza, localização e movimento dos elementos de dados dentro do sistema são, muitas vezes, os únicos e mais relevantes determinantes do comportamento do sistema.